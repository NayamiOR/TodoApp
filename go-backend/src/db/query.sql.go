// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSubTaskToTodo = `-- name: AddSubTaskToTodo :exec
UPDATE todos SET
                 sub_tasks = array_append(sub_tasks, $2),
                 updated_at = NOW()
WHERE id = $1 AND user_id = $3
`

type AddSubTaskToTodoParams struct {
	ID          int64
	ArrayAppend interface{}
	UserID      int64
}

func (q *Queries) AddSubTaskToTodo(ctx context.Context, arg AddSubTaskToTodoParams) error {
	_, err := q.db.Exec(ctx, addSubTaskToTodo, arg.ID, arg.ArrayAppend, arg.UserID)
	return err
}

const cancelPomo = `-- name: CancelPomo :exec
UPDATE pomos SET
                 status = 'cancelled',
                 stopped_at = NOW(),
                 duration_seconds = EXTRACT(EPOCH FROM (NOW() - started_at))::INTEGER,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND status IN ('running', 'paused')
`

type CancelPomoParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) CancelPomo(ctx context.Context, arg CancelPomoParams) error {
	_, err := q.db.Exec(ctx, cancelPomo, arg.ID, arg.UserID)
	return err
}

const completePomo = `-- name: CompletePomo :exec
UPDATE pomos SET
                 status = 'finished',
                 ended_at = NOW(),
                 duration_seconds = EXTRACT(EPOCH FROM (NOW() - started_at))::INTEGER,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND status = 'running'
`

type CompletePomoParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) CompletePomo(ctx context.Context, arg CompletePomoParams) error {
	_, err := q.db.Exec(ctx, completePomo, arg.ID, arg.UserID)
	return err
}

const createPomo = `-- name: CreatePomo :one

INSERT INTO pomos (user_id, topic, todo_id, is_positive, status, started_at, duration_seconds)
VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING id, user_id, status, started_at, ended_at, duration_seconds, is_positive, topic, todo_id, note, created_at, updated_at
`

type CreatePomoParams struct {
	UserID          int64
	Topic           pgtype.Text
	TodoID          pgtype.Int8
	IsPositive      bool
	Status          string
	StartedAt       pgtype.Timestamptz
	DurationSeconds pgtype.Int4
}

// ==================== POMOS ====================
func (q *Queries) CreatePomo(ctx context.Context, arg CreatePomoParams) (Pomo, error) {
	row := q.db.QueryRow(ctx, createPomo,
		arg.UserID,
		arg.Topic,
		arg.TodoID,
		arg.IsPositive,
		arg.Status,
		arg.StartedAt,
		arg.DurationSeconds,
	)
	var i Pomo
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.IsPositive,
		&i.Topic,
		&i.TodoID,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTodo = `-- name: CreateTodo :one

INSERT INTO todos (title, description, status, user_id, parent_id, sub_tasks)
VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING id, title, description, status, user_id, parent_id, sub_tasks, created_at, updated_at
`

type CreateTodoParams struct {
	Title       string
	Description pgtype.Text
	Status      string
	UserID      int64
	ParentID    pgtype.Int8
	SubTasks    []int64
}

// ==================== TODOS ====================
func (q *Queries) CreateTodo(ctx context.Context, arg CreateTodoParams) (Todo, error) {
	row := q.db.QueryRow(ctx, createTodo,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.UserID,
		arg.ParentID,
		arg.SubTasks,
	)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.UserID,
		&i.ParentID,
		&i.SubTasks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one


INSERT INTO users (username, email, password_hash)
VALUES ($1, $2, $3)
    RETURNING id, username, email, password_hash, is_active, created_at, updated_at
`

type CreateUserParams struct {
	Username     string
	Email        string
	PasswordHash string
}

// query.sql
// ==================== USERS ====================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Email, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePomo = `-- name: DeletePomo :exec
DELETE FROM pomos WHERE id = $1 AND user_id = $2
`

type DeletePomoParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeletePomo(ctx context.Context, arg DeletePomoParams) error {
	_, err := q.db.Exec(ctx, deletePomo, arg.ID, arg.UserID)
	return err
}

const deleteTodo = `-- name: DeleteTodo :exec
DELETE FROM todos WHERE id = $1 AND user_id = $2
`

type DeleteTodoParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteTodo(ctx context.Context, arg DeleteTodoParams) error {
	_, err := q.db.Exec(ctx, deleteTodo, arg.ID, arg.UserID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getActivePomoForUser = `-- name: GetActivePomoForUser :one
SELECT id, user_id, status, started_at, ended_at, duration_seconds, is_positive, topic, todo_id, note, created_at, updated_at FROM pomos
WHERE user_id = $1 AND status IN ('running', 'paused')
ORDER BY started_at DESC LIMIT 1
`

func (q *Queries) GetActivePomoForUser(ctx context.Context, userID int64) (Pomo, error) {
	row := q.db.QueryRow(ctx, getActivePomoForUser, userID)
	var i Pomo
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.IsPositive,
		&i.Topic,
		&i.TodoID,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPomoByIDAndUserID = `-- name: GetPomoByIDAndUserID :one
SELECT id, user_id, status, started_at, ended_at, duration_seconds, is_positive, topic, todo_id, note, created_at, updated_at FROM pomos WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetPomoByIDAndUserIDParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) GetPomoByIDAndUserID(ctx context.Context, arg GetPomoByIDAndUserIDParams) (Pomo, error) {
	row := q.db.QueryRow(ctx, getPomoByIDAndUserID, arg.ID, arg.UserID)
	var i Pomo
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.IsPositive,
		&i.Topic,
		&i.TodoID,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTodoByIDAndUserID = `-- name: GetTodoByIDAndUserID :one
SELECT id, title, description, status, user_id, parent_id, sub_tasks, created_at, updated_at FROM todos WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetTodoByIDAndUserIDParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) GetTodoByIDAndUserID(ctx context.Context, arg GetTodoByIDAndUserIDParams) (Todo, error) {
	row := q.db.QueryRow(ctx, getTodoByIDAndUserID, arg.ID, arg.UserID)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.UserID,
		&i.ParentID,
		&i.SubTasks,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, is_active, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsernameOrEmail = `-- name: GetUserByUsernameOrEmail :one
SELECT id, username, email, password_hash, is_active, created_at, updated_at FROM users WHERE username = $1 OR email = $2 LIMIT 1
`

type GetUserByUsernameOrEmailParams struct {
	Username string
	Email    string
}

func (q *Queries) GetUserByUsernameOrEmail(ctx context.Context, arg GetUserByUsernameOrEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsernameOrEmail, arg.Username, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFinishedPomosByUserID = `-- name: ListFinishedPomosByUserID :many
SELECT id, user_id, status, started_at, ended_at, duration_seconds, is_positive, topic, todo_id, note, created_at, updated_at FROM pomos
WHERE user_id = $1 AND status = 'finished'
ORDER BY ended_at DESC
`

func (q *Queries) ListFinishedPomosByUserID(ctx context.Context, userID int64) ([]Pomo, error) {
	rows, err := q.db.Query(ctx, listFinishedPomosByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pomo
	for rows.Next() {
		var i Pomo
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.IsPositive,
			&i.Topic,
			&i.TodoID,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingTodosByUserID = `-- name: ListPendingTodosByUserID :many
SELECT id, title, description, status, user_id, parent_id, sub_tasks, created_at, updated_at FROM todos WHERE user_id = $1 AND status = 'pending' ORDER BY created_at DESC
`

func (q *Queries) ListPendingTodosByUserID(ctx context.Context, userID int64) ([]Todo, error) {
	rows, err := q.db.Query(ctx, listPendingTodosByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.UserID,
			&i.ParentID,
			&i.SubTasks,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPomosByUserID = `-- name: ListPomosByUserID :many
SELECT id, user_id, status, started_at, ended_at, duration_seconds, is_positive, topic, todo_id, note, created_at, updated_at FROM pomos
WHERE user_id = $1 AND status != 'cancelled'
ORDER BY started_at DESC
`

func (q *Queries) ListPomosByUserID(ctx context.Context, userID int64) ([]Pomo, error) {
	rows, err := q.db.Query(ctx, listPomosByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pomo
	for rows.Next() {
		var i Pomo
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationSeconds,
			&i.IsPositive,
			&i.Topic,
			&i.TodoID,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodosByUserID = `-- name: ListTodosByUserID :many
SELECT id, title, description, status, user_id, parent_id, sub_tasks, created_at, updated_at FROM todos WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListTodosByUserID(ctx context.Context, userID int64) ([]Todo, error) {
	rows, err := q.db.Query(ctx, listTodosByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.UserID,
			&i.ParentID,
			&i.SubTasks,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password_hash, is_active, created_at, updated_at FROM users ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pausePomo = `-- name: PausePomo :exec
UPDATE pomos SET
                 status = 'paused',
                 duration_seconds = $2,
                 updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND status = 'running'
`

type PausePomoParams struct {
	ID              int64
	DurationSeconds pgtype.Int4
}

func (q *Queries) PausePomo(ctx context.Context, arg PausePomoParams) error {
	_, err := q.db.Exec(ctx, pausePomo, arg.ID, arg.DurationSeconds)
	return err
}

const removeSubTaskFromTodo = `-- name: RemoveSubTaskFromTodo :exec
UPDATE todos SET
                 sub_tasks = array_remove(sub_tasks, $2),
                 updated_at = NOW()
WHERE id = $1 AND user_id = $3
`

type RemoveSubTaskFromTodoParams struct {
	ID          int64
	ArrayRemove interface{}
	UserID      int64
}

func (q *Queries) RemoveSubTaskFromTodo(ctx context.Context, arg RemoveSubTaskFromTodoParams) error {
	_, err := q.db.Exec(ctx, removeSubTaskFromTodo, arg.ID, arg.ArrayRemove, arg.UserID)
	return err
}

const resumePomo = `-- name: ResumePomo :exec
UPDATE pomos SET
                 status = 'running',
                 updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND status = 'paused'
`

type ResumePomoParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) ResumePomo(ctx context.Context, arg ResumePomoParams) error {
	_, err := q.db.Exec(ctx, resumePomo, arg.ID, arg.UserID)
	return err
}

const startPomo = `-- name: StartPomo :one
INSERT INTO pomos (user_id, topic, todo_id, is_positive, status, started_at, duration_seconds)
VALUES ($1, $2, $3, $4, 'running', NOW(), 0)
    RETURNING id, user_id, status, started_at, ended_at, duration_seconds, is_positive, topic, todo_id, note, created_at, updated_at
`

type StartPomoParams struct {
	UserID     int64
	Topic      pgtype.Text
	TodoID     pgtype.Int8
	IsPositive bool
}

func (q *Queries) StartPomo(ctx context.Context, arg StartPomoParams) (Pomo, error) {
	row := q.db.QueryRow(ctx, startPomo,
		arg.UserID,
		arg.Topic,
		arg.TodoID,
		arg.IsPositive,
	)
	var i Pomo
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationSeconds,
		&i.IsPositive,
		&i.Topic,
		&i.TodoID,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTodoStatus = `-- name: UpdateTodoStatus :exec
UPDATE todos SET
                 status = $2,
                 updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type UpdateTodoStatusParams struct {
	ID     int64
	Status string
}

func (q *Queries) UpdateTodoStatus(ctx context.Context, arg UpdateTodoStatusParams) error {
	_, err := q.db.Exec(ctx, updateTodoStatus, arg.ID, arg.Status)
	return err
}

const updateTodoTitleAndDesc = `-- name: UpdateTodoTitleAndDesc :exec
UPDATE todos SET
                 title = $2,
                 description = $3,
                 updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type UpdateTodoTitleAndDescParams struct {
	ID          int64
	Title       string
	Description pgtype.Text
}

func (q *Queries) UpdateTodoTitleAndDesc(ctx context.Context, arg UpdateTodoTitleAndDescParams) error {
	_, err := q.db.Exec(ctx, updateTodoTitleAndDesc, arg.ID, arg.Title, arg.Description)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET
                 username = $2,
                 email = $3,
                 password_hash = $4,
                 is_active = $5,
                 updated_at = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID           int64
	Username     string
	Email        string
	PasswordHash string
	IsActive     bool
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.IsActive,
	)
	return err
}
